<big>'''Алгоритм шифрування ICEBERG'''</big> (''"Involutional Cipher Efficient for Block Encryption in Reconfigurable Hardware" - "Інволюційний шифр для ефективного блокового шифрування в реконфігурованому апаратному забезпеченні" '') - блоковий [[шифр]], розроблений для реконфігурованих апаратних реалізацій.
<br><br>ICEBERG запропонований відносно нещодавно у 2004 р. – французьким криптологом Жилем-Франсуа Піре (Gilles-François Piret). Як видно з назви, цей алгоритм оптимізовано під апаратні реалізації за допомогою програмованих логічних інтегральних схем. 
<br><br>

=='''Структура алгоритму'''==
[[Алгоритм]] ICEBERG шифрує дані 64-бітових блоків з використанням 128-бітного ключа шифрування. Оброблюваний блок даних подається у вигляді 64-бітового вектору, над яким у кожному раунді алгоритму послідовно виконуються такі операції:
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture1.png|thumb|]]
|}
1. Таблична заміна . Вектор даних подається у вигляді 16 значень по 4 біти, кожне з яких заміщається згідно з таблицею:
<br>
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture2.png|thumb|]]
|}
2. Бітова перестановка P8, що переставляє біти вектору даних за наступним правилом:
''y<sub>8i+j</sub> = x<sub>8i+p8(j)</sub>, i = 0...7, j = 0...7,
''<br>
де:
<br>
▪ ''x<sub>n</sub>'' та ''y<sub>n</sub>'' - відповідно, вхідний та вихідний біти вектору даних;
<br>
▪функція ''p8()'' визначена згідно таблиці:
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture3.png|thumb|]]
|}
3. Таблична заміна , що працює аналогічно до заміни , але згідно з іншою таблицею:
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture4.png|thumb|]]
|}
4. Знову виконується перестановка P8, після якої повторно застосовується таблична заміна S<sub>0</sub>.
<br>
5. Бітова перестановка Р64, що переставляє біти вектору даних наступним чином:
<br>''y<sub>i</sub> = x<sub>p64(i)</sub>, i = 0...63,''
<br> де функція р64() визначена згідно таблиці:
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture5.png|thumb|]]
|}
Згідно таблиці вхідним значенням 0, 1, 2, ... відповідають вихідні значення 0, 12, 23 і т.д.
6. Операція множення на матрицю М. Застосовується до кожного 4-бітного фрагмента вектору даних шляхом його множення на фіксовану матрицю<br>
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture6.png|thumb|]]
|}
Це аналогічно до застосування наступної табличної заміни: 
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture7.png|thumb|]]
|}
7. Накладання матеріалу ключа (операція δ):
<br>''y<sub>i</sub> = x<sub>i</sub>⊕RK[n], ''
<br> де RK[n]<sub>i</sub>- і-й біт фрагмента розширеного ключа для n-го раунду (процедура розширення ключа буде описана далі).
8. Бітова перестановка Р4, яка застосовується до кожного 4-бітного фрагмента векторних даних:
<br>''y[i]<sub>j</sub> = x[i]<sub>p4(j)</sub>, i = 0...15, j = 0...3, ''
<br>  y[i] та x[i] - відповідно, вхідне та вихідне значенння і-го 4-бітного фрагмента, а функція р4() визначається згідно таблиці
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture8.png|thumb|]]
|}
9. Повторно застосовується описана вище операція Р64.
<br>
<br>
Алгоритм складається із 15 раундів перетворень. Перед першим раундом виконується попереднє накладення ключа, а після заключного раунду - фінальне перетворення, що складається з наступних операцій (описаних вище): <br>
* 
* 	табличної заміни S<sub>0</sub>;<br>
* 
* 	бітової перестановки P8; <br>
* 
* 	табличні заміни S<sub>1</sub>;<br>
* 
* 	бітової перестановки P8; <br>
* 
* 	табличної заміни S<sub>0</sub>.<br>
* 
	При розшифруванні виконуються абсолютно ті ж операції, але фрагменти розширеного ключа використовуються у зворотному порядку (при цьому вони формуються дещо інакше, ніж при зашифруванні - див. далі).
=='''Процедура розширення ключа'''<br>==
Процедура розширення ключа складається із декількох етапів. На першому етапі з вихідного 128-бітного ключа шифрування К наступним чином обчислюється послідовність 128-бітових проміжних ключів IK<sub>0</sub>...IK<sub>16</sub>:
<br>	IK<sub>0</sub> = K;
<br>	IK<sub>i+1</sub> = G(IK<sub>i</sub>,C<sub>i</sub>),
<br>де G() - раунд процедури розширення ключа, а C<sub>i</sub> - модифікуючі константи.
<br> У кожному раунді виконується наступна послідовність дій:
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture9.png|thumb|]]
|}
1. Операція τ здійснює циклічний зсув вхідних даних в залежності від значення C<sub>i</sub>:
* при C<sub>i</sub> = 0 виконується обертання на 8 бітів ліворуч;
* при C<sub>i</sub> = 1 - циклічний зсув на 8 бітів праворуч.
Константи C<sub>i</sub> визначено як 0 для першої половини раундів, тобто для i=0...7, для решти раундів C<sub>i</sub> = 1.
<br>2. Бітова перестановка Р128 здійснює перестановку за наступним законом:
<br> ''y<sub>i</sub> = x<sub>p128(i)</sub>, i = 0...127'',
<br>де функція р128() визначена згідно таблиці:
{| style="margin: 0 auto;"
|[[File:ICEBERG Picture10.png|thumb|]]
|}
Вхідні значення 0, 1, 2, ... відповідають вихідні значення 76, 110, 83 і т.д.
<br>3. До 4-бітних фрагментів оброблюваних даних застосовується описана вище таблична заміна S<sub>0</sub>.
4. Повторно застосовується перестановка Р128, після якої повторно виконується операція τ.
<br><br>
На наступному етапі формується 64-бітові підключі IK'<sub>0</sub>...IK'<sub>16</sub>, які просто “набираються” зі значень непарних бітів відповідних проміжних ключів IK<sub>0</sub>...IK<sub>16</sub>.
<br>
На заключному етапі процедури розширення ключа обчислюється раундові ключі RK[n]. Для цього кожен 4-бітний фрагмент кожного підключа IK'<sub>0</sub>...IK'<sub>16</sub> паралельно обробляється операцією φ, яка визначена наступним чином:
<br>''y<sub>0</sub> = ((x<sub>0</sub>⊕x<sub>1</sub>⊕x<sub>2</sub>)&b)|((x<sub>0</sub>⊕x<sub>1</sub>&(~b)); ''
<br>''y<sub>1</sub> = ((x<sub>1</sub>⊕x<sub>2</sub>)&b)|((x<sub>1</sub>&(~b)); ''
<br>''y<sub>2</sub> = ((x<sub>2</sub>⊕x<sub>3</sub>⊕x<sub>0</sub>)&b)|((x<sub>2</sub>⊕x<sub>3</sub>&(~b)); ''
<br>''y<sub>3</sub> = ((x<sub>3</sub>⊕x<sub>0</sub>)&b)|((x<sub>3</sub>&(~b)),''
<br>
де:
* y<sub>i</sub> та x<sub>i</sub>  - i-ті біти, відповідно, вхідного і вихідного значення;
* b - модифікуючий біт, його призначення буде пояснено далі;
* ~ - логічна операція заперечення;
* & - логічна операція “і”;
* | - логічна операція “або”.
Модифікуючий біт b керує формуванням різних значень підключів для зашифрування та розшифрування:
* при зашифруванні для операції попереднього накладання ключа і 15 раундів перетворень відповідні підключі (RK[0] і RK[1]...RK[15]) формуються зі значенням b = 1; підключ RK[16], що використовується у фінальному перетворенні, формується зі значенням b = 0;
* при розшифруванні для попереднього накладання ключа і 15 раундів перетворень використовуються, відповідно, фрагменти RK[16] і RK[15]...RK[1], які формуються з модифікуючим бітом b=0; підключ RK[0], що використовується у фінальному перетворенні, формується зі значенням b = 1.

=='''Криптоаналіз алгоритму'''<br>==
Алгоритм ICEBERG з’явився відносно нещодавно і, мабуть, не викликав широкого інтересу з боку криптологів - будь-які роботи, присвяченні криптоаналізу даного алгоритму, не набули широкої популярності.

=='''Джерела'''<br>==
Панасенко С. Алгоритмы шифрования. Специальный справочник. СПб.:БХВ-Петербург, 2009.- 576 с.
